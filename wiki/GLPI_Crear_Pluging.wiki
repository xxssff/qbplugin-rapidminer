A plugin is an add code, which allows features to enrich GLPI without having to add patches to the main code of the application.
All plugins are stored in the subversion of GLPI, at[[https://dev.indepnet.net/plugins/browser/]].

Il existe un plugin example, présentant l'ensemble des fonctionnalités [[https://dev.indepnet.net/plugins/browser/example]].
Le plugin room est un cas concret simple assez complet également [[https://dev.indepnet.net/plugins/browser/room]]

= Fonctionnement d'un plugin GLPI =
Le plug-in se présente sous la forme d'un dossier à ajouter dans le répertoire plugins de l'arborescence de GLPI.
Ce dossier va contenir tous les fichiers php (et images par exemple).

'''Ce répertoire ne doit comprendre que des caractères alpahnumériques (pas de - _ ou autre)'''

Un plugin ne modifie jamais les tables de GLPI. Il se contente d'ajouter des tables dans la base, pour gérer ses propres données.

= Comment écrire un plugin pour GLPI ? =

== Conventions de programmation ==

1- Noms de tables

 * Vos noms de tables doivent respecter ce type glpi_plugin_<plugin_name>_XXXX
 * Si vous utilisez des dropdown, veuillez pour la table utiliser : glpi_dropdown_plugin_<plugin_name>_XXXX

2- Bien respecter l'architecture de création de plugins :

 * Un répertoire "locales" : dictionnaires
   * Les dictionnaires seront du type : fr_FR.php / en_GB.php
 * Un répertoire "docs" : 
   * Readme.txt, Lisezmoi.txt, Roadmap.txt, Changelog.txt
 * Un répertoire "inc" : contient les classes et fonctions
   * Les noms de fichiers devront être taggués : exemple plugin_<plugin_name>.functions_db.php
   * Les classes créées devront être tagguées : class plugin_<plugin_name>
   * Les fonctions devront être tagguées : function plugin_<plugin_name>_showform
 * Un répertoire "front" : contient les formulaires
   * Les noms de fichiers devront être taggués : exemple plugin_<plugin_name>.form.php
 * Un répertoire "pics" : contient les images
 * A la racine :
   * Au moins un index.php et un setup.php

 * Si votre plugin doit créer des fichiers, ceux-ci doivent être créés dans le répertoire files de GLPI sous files_plugins/nom_de_votre_plugin.

Ceci ve permettre d'éviter la gestion des droits d'écriture à chaque release de votre plugin.
Les droits lors de l'installation ou la mise à jour de GLPI s'appliqueront.
Tout ceci dans le but de ne pas interférer avec le core de GLPI.

 
3- Look et Aspect du plugin :

Pour qu'il s'intègre au mieux dans GLPI le mieux est de réutiliser les classes de mise en forme déjà définies et utilisées dans GLPI.
Vous trouverez l'ensemble de ces définitions dans le fichier CSS de GLPI.

Merci de respecter ceci afin d'harmoniser les plugins et leurs futurs développements.

== Structure de fichiers d'un plugin ==
La structure minimale est la suivante :
{{{glpi/plugins/PLUGIN_NAME}}} : le répertoire du plugin
{{{glpi/plugins/PLUGIN_NAME/setup.php}}} : fichier qui contient le code même du plugin.

Vous pouvez également rajouter autant de fichiers que vous le désirez.

== Le fichier setup.php ==

Ce fichier doit contenir au minimum 2 fonctions :

{{{plugin_init_PLUGIN_NAME()}}} : définit la configuration du plugin, ce qu'il fait... Cette fonction va être lancée à chaque appel de page de GLPI.
{{{plugin_version_PLUGIN_NAME()}}} : définit le nom et la version du plugin


La fonction plugin_init_PLUGIN_NAME va permettre de définir tous les comportements du plugin qui peuvent être de type différent :
 - Intégration visuelle du plugin au sein de GLPI
 - Hooks / actions exécutées sur évènement spécifiques
 - Localisation
 - Gestion des dropdowns
 - Utilisation du moteur de recherche
 - Interactions diverses : planning, redirection, cron, ...


=== Intégration visuelle ===

L'existence du plugin est réalisée en définissant tout d'abord la fonction plugin_version_PLUGIN_NAME comme ceci :
{{{
function plugin_version_PLUGIN_NAME(){
	return array( 'name'    => 'Name of my plugin',
			'version' => '0.0.1');
}
}}}

Au sein de la fonction plugin_init_PLUGIN_NAME des directives peuvent être ajoutées pour activer certaines fonctionnalités du plugin.

- {{{$PLUGIN_HOOKS['helpdesk_menu_entry']['PLUGIN_NAME'] = true;}}} : indique si le plugin doit être affiché dans la liste des plugins du menu de l'interface helpdesk.

- {{{$PLUGIN_HOOKS['menu_entry']['PLUGIN_NAME'] = true;}}} : indique si le plugin doit être affiché dans la liste des plugins du menu de l'interface central.

- {{{$PLUGIN_HOOKS['submenu_entry']['PLUGIN_NAME'][ACTION] = LINK;}}} : Définit si nécessaire les sous-menus pour l'interface central.
{{{ACTION}}} définit l'élément affiché dans le sous-menu. Des actions par défaut sont définies dans GLPI (add, search, template, showall et summary).
Pour ces actions des icônes standard seront utilisées. Mais vous pouvez aussi choisir d'afficher un texte ou une icône personnelle (cf. plugin example).

ou :

- {{{$PLUGIN_HOOKS['submenu_entry']['PLUGIN_NAME'][ACTION][OPTION] = LINK;}}} : Définit si nécessaire les sous-menus pour l'interface central.
Il est possible d'afficher un lien personnalisé en fonction du paramètre OPTION. Cela permet de pouvoir changer le lien en fonction de la sous rubrique dans laquelle on se trouve.

- {{{$PLUGIN_HOOKS['config_page']['PLUGIN_NAME'] = 'config.php';}}} : Page de l'arborescence du plugin apparaissant dans Configuration / Plugins.

- 0.71 : {{{$PLUGIN_HOOKS['central_action']['PLUGIN_NAME'] = 'plugin_central_action_PLUGIN_NAME';}}} : Définition d'une action spécifique pour la page du tableau de bord du central. 
plugin_central_action_PLUGIN_NAME est une fonction sans paramètre :
{{{
// Hook to be launch on central
function plugin_central_action_PLUGIN_NAME(){
	echo "<div align='center'>";
	echo "Plugin central action";
	echo "</div>";
}
}}}
'''en 0.72 même système que les headings classiques avec comme type ''central'' '''  


- {{{$PLUGIN_HOOKS['headings']['PLUGIN_NAME'] = 'plugin_get_headings_PLUGIN_NAME';}}} : Fonction définissant les entrées dans les onglets des différents types de GLPI.
0.72 : 2 types supplémentaires peuvent être utilisés : central et prefs pour l'affichage sur la page d'accueil du central et des préférences utilisateurs.
Cette fonction, qui est définie dans le setup.php, prend alors la forme suivante :
{{{
function plugin_get_headings_example($type,$withtemplate){
	switch ($type){
		case COMPUTER_TYPE :
			// template case
			if ($withtemplate){
				return array();
			} else { // Non template case
				return array(1 => "Test Plugin");
                        }
			break;
		case ENTERPRISE_TYPE :
			return array(
					1 => "Test Plugin",
					2 => "Test Plugin 2",
				    );
			break;
	}
	return false;
}
}}}
 
- {{{$PLUGIN_HOOKS['headings_action']['PLUGIN_NAME'] = 'plugin_headings_actions_PLUGIN_NAME';}}} : Fonction définissant les actions réalisées par les onglets des différents types de GLPI
Cette fonction, définit dans le setup.php, prend alors la forme suivante (chaque définition correspond au nom de la fonction qui sera exécutée) :
{{{
// Define headings actions added by the plugin	 
function plugin_headings_actions_example($type){

	switch ($type){
		case COMPUTER_TYPE :
			return array(1 => "plugin_example_function1");

			break;
		case ENTERPRISE_TYPE :
			return array(
					1 => "plugin_example_function2",
					2 => "plugin_example_function3",
				    );
			break;
	}
	return false;
}
}}}

Les fonctions d'affichage ont alors le prototype suivant :
{{{
// Example of an action heading
function plugin_example_function2($type,$ID,$withtemplate=0){
	if (!$withtemplate){
		echo "<div align='center'>";
		echo "Plugin function with headings TYPE=".$type." ID=".$ID;
		echo "</div>";
	}
}
}}}


=== Hooks sur des actions de GLPI ===

  Un plugin peut se greffer sur chaque action réalisée dans GLPI pour effectuer ses propres traitements.
  Pour cela on indique les noms des fonctions à exécuter à ce moment là.
  {{{  
  $PLUGIN_HOOKS['item_update']['PLUGIN_NAME'] = 'plugin_item_update_PLUGIN_NAME'; 
  $PLUGIN_HOOKS['item_add']['PLUGIN_NAME'] = 'plugin_item_add_PLUGIN_NAME';
  $PLUGIN_HOOKS['item_delete']['PLUGIN_NAME'] = 'plugin_item_delete_PLUGIN_NAME';
  $PLUGIN_HOOKS['item_purge']['PLUGIN_NAME'] = 'plugin_item_purge_PLUGIN_NAME';
  $PLUGIN_HOOKS['item_restore']['PLUGIN_NAME'] = 'plugin_item_restore_PLUGIN_NAME';
  }}}
  Ces fonctions utilisent le prototype suivant ($parm contenant 2 champs 'type' et 'ID' définissant le type et l'ID de l'élément sur lequel a été réalisé l'action) :
  {{{
// Hook done on add item case
function plugin_item_add_PLUGIN_NAME($parm){

	if (isset($parm["type"]))
		switch ($parm["type"]){
			case COMPUTER_TYPE :
				if (!empty($_SESSION["MESSAGE_AFTER_REDIRECT"])) $_SESSION["MESSAGE_AFTER_REDIRECT"].="<br>";
				$_SESSION["MESSAGE_AFTER_REDIRECT"].="Add Computer Hook ".$parm["ID"];
				return true;
				break;
		}
	return false;
}
  }}}
[[https://dev.indepnet.net/plugins/wiki/HowtoHook Information sur les hooks]]

=== Localisation ===

Tous les textes du plugin qui seront affichés dans GLPI doivent être externalisés dans un fichier, afin de pouvoir facilement traduire l'interface (juste besoin de traduire un fichier).
Les fichiers de langue se trouvent dans le répertoire locales/
La convention pour le nommage d'un fichier de langue est le même que celui de GLPI et utilise la norme i18n :
 * fr_FR pour la France, 
 * en_GB pour l'Angleterre

A l'intérieur du fichier, les libellés sont tous stockés dans un tableau dont voici un exemple :
{{{
  $LANGMYPLUGIN["title"][0] = "mon titre";
  $LANGMYPLUGIN["myplugin"][1] = "libellé 1";
  $LANGMYPLUGIN["myplugin"][2] = "libellé 2";
}}}

Le fichier de langue correspondant à la langue courante de l'utilisateur sera chargé dynamiquement.
S'il n'existe pas GLPI tentera de charger successivement celui de la langue par défaut, de l'anglais puis du français.

=== Interactions diverses ===

==== Ajout Javascript et CSS ====

Vous pouvez ajouter des scripts javascript pour vos propres besoins ainsi que des fichiers de style CSS en utilisant les définitions suivantes :
{{{$PLUGIN_HOOKS['add_javascript']['PLUGIN_NAME']="FILENAME.js";}}
$PLUGIN_HOOKS['add_css']['PLUGIN_NAME']="FILENAME.css";
}}}


==== Planning ====

Deux fonctions peuvent être définies et permettent de peupler le planning qui sera affiché et de définir comment les éléments seront affichés :
 - Pour pouvoir peupler le planning : {{{$PLUGIN_HOOKS['planning_populate']['PLUGIN_NAME']="plugin_planning_populate_PLUGIN_NAME";}}}
   La fonction ainsi définit remplit un tableau dont les éléments peuvent être triés suivant leur clés.
Par exemple :
{{{
// Parm contains 'begin', 'end' and 'who'
// Create data to be displayed in the planning of $parm["who"] between $parm["begin"] and $parm["end"] 
function plugin_planning_populate_example($parm){

	// Add items in the items fields of the parm array
	// Items need to have an unique index beginning by the begin date of the item to display
	// needed to be correcly displayed

	list($date,$time)=split(" ",$parm["begin"]);
	$end=$date." 13:33:00";

	$parm["items"][$parm["begin"]."$$$"."plugin_example1"]["plugin"]="example";
	$parm["items"][$parm["begin"]."$$$"."plugin_example1"]["begin"]=$parm["begin"];
	$parm["items"][$parm["begin"]."$$$"."plugin_example1"]["end"]=$end;
	$parm["items"][$parm["begin"]."$$$"."plugin_example1"]["name"]="test planning example 1 ";

	return $parm;
}
}}}
 - Pour définir l'affichage dans le planning : {{{$PLUGIN_HOOKS['display_planning']['example']="plugin_display_planning_PLUGIN_NAME";}}}
{{{
// Display the planning item
function plugin_display_planning_PLUGIN_NAME($parm){
	// $parm["type"] say begin end in or from type
	// Add items in the items fields of the parm array
	global $LANG;
	switch ($parm["type"]){
		case "in":
			echo date("H:i",strtotime($parm["begin"]))." -> ".date("H:i",strtotime($parm["end"])).": ";
			break;
		case "from":
			break;
		case "begin";
			echo $LANG["planning"][19]." ".date("H:i",strtotime($parm["begin"])).": ";
			break;
		case "end";
			echo $LANG["planning"][20]." ".date("H:i",strtotime($parm["end"])).": ";
			break;
	}
	echo $parm["name"];
}
}}}


==== Cron ====

Vous pouvez ajouter une tache planifiée par plugin.
Pour cela il suffit de définir :
{{{$PLUGIN_HOOKS['cron']['PLUGIN_NAME'] = DAY_TIMESTAMP;}}}
Cette directive lancera la fonction {{{cron_plugin_PLUGIN_NAME}}} de manière régulière en tache de fond (ici tous les jours).

==== Redirection ====

L'appel à la page de connexion permet une redirection automatique (par exemple pour une accès lors de l'envoi d'un lien par mail).
Vous pouvez effectuer une redirection automatique vers une page de votre plugin en définissant :
{{{$PLUGIN_HOOKS['redirect_page']['PLUGIN_NAME']="PAGE_TO_REDIRECT.php";}}}
l'appel à {{{index.php?redirect=plugin_PLUGINNAME_IDTOREDIRECT}}}  redirigera vers  {{{plugins/PLUGINNAME/PAGE_TO_REDIRECT.php?ID=IDTOREDIRECT}}}

== Utilisation de l'API de GLPI ==

=== Gestion des dropdowns ===

Pour pouvoir utiliser les fonctions de dropdown.function.php comme dropdownValue, il suffit de définir la fonction plugin_PLUGIN_NAME_getDropdown qui définit ses plugins :

{{{ 
// Define Dropdown tables to be manage in GLPI :
function plugin_example_getDropdown(){
	// Table => Name
	return array("glpi_dropdown_plugin_example"=>"Plugin Example Dropdown");
}
}}}

Pour un dropdown simple cela suffit. Pour un dropdown arborescent il vous faut spécifier que la table est de ce type :

{{{ array_push($CFG_GLPI["dropdowntree_tables"],"glpi_dropdown_plugin_PLUGIN_NAME");}}}

Si c'est un dropdown séparé pour chaque entité :
{{{ array_push($CFG_GLPI["specif_entities_tables"],"glpi_dropdown_plugin_PLUGIN_NAME");}}}

Pour pouvoir gérer automatiquement l'édition des éléments du dropdown avec remplacement ou suppression des valeurs en cas de suppression vous pouvez décrire les relations existantes entre les tables de vos plugins en ajoutant la fonction :
{{{
// Define dropdown relations
function plugin_example_getDatabaseRelations(){
	// 
	return array("glpi_dropdown_plugin_example"=>array("glpi_plugin_example"=>"FK_dropdown"));
}
}}}
Ici le champ FK_dropdown de glpi_plugin_example est lié à la table glpi_dropdown_plugin_example.

=== Définition d'un nouveau type d'objet ===

Pour cela vous pouvez utiliser la fonction pluginNewType :
{{{pluginNewType('example',"PLUGIN_EXAMPLE_TYPE",1001,"pluginExample","glpi_plugin_example","example.form.php","Example",false);}}}

Elle prend en paramètre : le nom du plugin / la chaine définissant le type / le numéro du type / la classe associée / la table associée / la page de formulaire associée si elle existe / le nom du type / si le type est récursif.

Les numéros des types de plugins sont réservables par tranche de 100 ici : PluginTypesReservation. Ils démarrent à partir de 1000.

Pour pouvoir utiliser la fonction haveTypeRight de GLPI vous devez définir comment sont gérés les droits sur ce nouvel objet en redéfinissant la fonction :
{{{
// Define rights for the plugin types
function plugin_example_haveTypeRight($type,$right){
	switch ($type){
		case PLUGIN_EXAMPLE_TYPE :
			// 1 - All rights for all users
			// return true;
			// 2 - Similarity right : same right of computer
			return haveRight("computer",$right);
                        // 3 - Specific right management
			break;
	}
}
}}}
The definition of the rights is needed to use the massive action system of the search system (only available for users who have 'w' right on the defined type).


=== Utiliser CommonDBTM ===

Si vous définissez un nouveau type il vous faut également définir la classe associée à ce nouveau type.
Elle doit hériter de la classe CommonDBTM qui permet de s'abstraire de tous les accès directs à la base de données.
Sa définition minimale est du type :
{{{
class pluginExample extends CommonDBTM {
	function pluginExample () {
		$this->table="glpi_plugin_example";
		$this->type=PLUGIN_EXAMPLE_TYPE;
	}
};
}}}

Pour plus d'infos, sur les fonctions que vous pouvez surcharger, la documentation de cette classe se trouve ici :
https://dev.indepnet.net/glpidoc/classCommonDBTM.html

=== Utilisation du moteur de recherche ===

Vous devez tout d'abord définir un nouveau type (cf. plus haut).
Vous pouvez alors définir les éléments affichables dans votre moteur de recherche en définissant la fonction plugin_PLUGINNAME_getSearchOption :
{{{
function plugin_example_getSearchOption(){
	global $LANGEXAMPLE;
	$sopt=array();

        // Part header
	$sopt[PLUGIN_EXAMPLE_TYPE]['common']="Header Needed";


	$sopt[PLUGIN_EXAMPLE_TYPE][1]['table']='glpi_plugin_example';
	$sopt[PLUGIN_EXAMPLE_TYPE][1]['field']='name';
	$sopt[PLUGIN_EXAMPLE_TYPE][1]['linkfield']='name';
	$sopt[PLUGIN_EXAMPLE_TYPE][1]['name']=$LANGEXAMPLE["name"];

	$sopt[PLUGIN_EXAMPLE_TYPE][2]['table']='glpi_dropdown_plugin_example';
	$sopt[PLUGIN_EXAMPLE_TYPE][2]['field']='name';
	$sopt[PLUGIN_EXAMPLE_TYPE][2]['linkfield']='FK_dropdown';
	$sopt[PLUGIN_EXAMPLE_TYPE][2]['name']='Dropdown';
	
	return $sopt;
}
}}}

Le moteur de recherche s'appelle alors simplement :
{{{
manageGetValuesInSearch(PLUGIN_EXAMPLE_TYPE);

searchForm(PLUGIN_EXAMPLE_TYPE,$_SERVER['PHP_SELF'],$_GET["field"],$_GET["contains"],$_GET["sort"],$_GET["deleted"],$_GET["link"],$_GET["distinct"],$_GET["link2"],$_GET["contains2"],$_GET["field2"],$_GET["type2"]);

showList(PLUGIN_EXAMPLE_TYPE,$_SERVER['PHP_SELF'],$_GET["field"],$_GET["contains"],$_GET["sort"],$_GET["order"],$_GET["start"],$_GET["deleted"],$_GET["link"],$_GET["distinct"],$_GET["link2"],$_GET["contains2"],$_GET["field2"],$_GET["type2"]);
}}}

Vous pouvez également définir des cas particuliers de recherche en définissant une ou plusieurs des fonctions suivantes si nécessaire :

{{{

function plugin_example_addLeftJoin($type,$ref_table,$new_table,$linkfield,&$already_link_tables){
	switch ($new_table){
		case "glpi_dropdown_plugin_example" :
			// Standard LEFT JOIN for the example but use it for specific jointures
			return " LEFT JOIN $new_table ON ($ref_table.$linkfield = $new_table.ID) ";
			break;
	}
	return "";
}


function plugin_example_forceGroupBy($type){
	switch ($type){
		case PLUGIN_EXAMPLE_TYPE :
                        // Force add GROUP BY IN REQUEST
			return true;
			break;
	}
	return false;
}

function plugin_example_giveItem($type,$field,$data,$num,$linkfield=""){
	global $CFG_GLPI, $INFOFORM_PAGES;

	switch ($field){
		case "glpi_plugin_example.name" :
			$out= "<a href=\"".$CFG_GLPI["root_doc"]."/".$INFOFORM_PAGES[$type]."?ID=".$data['ID']."\">";
			$out.= $data["ITEM_$num"];
			if ($CFG_GLPI["view_ID"]||empty($data["ITEM_$num"])) $out.= " (".$data["ID"].")";
			$out.= "</a>";
			return $out;
			break;
	}
	return "";
}

function plugin_example_addWhere($link,$nott,$type,$ID,$val){
	global $SEARCH_OPTION;

	$table=$SEARCH_OPTION[$type][$ID]["table"];
	$field=$SEARCH_OPTION[$type][$ID]["field"];
	
	$SEARCH=makeTextSearch($val,$nott);

	switch ($table.".".$field){
		case "glpi_plugin_example.name" :
			// Standard Where clause for the example but use it for specific jointures
			$ADD="";	
			if ($nott&&$val!="NULL") {
				$ADD=" OR $table.$field IS NULL";
			}
			
			return $link." ($table.$field $SEARCH ".$ADD." ) ";
			break;
	}
	return "";
}

function plugin_example_addSelect($type,$ID,$num){
	global $SEARCH_OPTION;

	$table=$SEARCH_OPTION[$type][$ID]["table"];
	$field=$SEARCH_OPTION[$type][$ID]["field"];

	switch ($table.".".$field){
		case "glpi_plugin_example.name" :
			// Standard Select clause for the example but use it for specific selection
			return $table.".".$field." AS ITEM_$num, ";
			break;
	}
	return "";
}

function plugin_example_addOrderBy($type,$ID,$order,$key=0){
	global $SEARCH_OPTION;

	$table=$SEARCH_OPTION[$type][$ID]["table"];
	$field=$SEARCH_OPTION[$type][$ID]["field"];

	switch ($table.".".$field){
		case "glpi_plugin_example.name" :
			// Standard Order By clause for the example but use it for specific selection
			return " ORDER BY $table.$field $order ";
			break;
	}
	return "";
}

}}}

=== Définir des actions de modification massive ===

Par défaut les actions de type : modifier / supprimer / purger / restaurer sont accessibles depuis les listes.

Pour ajouter des actions spécifiques il faut tout d'abord ajouter :
$PLUGIN_HOOKS['use_massive_action']['PLUGIN_NAME']=1;

Dans le cas modifier : pour des champs ayant des modes de saisies particuliers vous pouvez les définir en définissant la fonction : plugin_PLUGINNAME_MassiveActionsFieldsDisplay($type,$table,$field,$linkfield). 
Celle-ci doit retourner true si l'element est affiché et false sinon (dans ce cas le mode d'affichage par défaut sera appliqué).
Un exemple :
{{{
// How to display specific update fields ?
function plugin_example_MassiveActionsFieldsDisplay($type,$table,$field,$linkfield){
	global $LINK_ID_TABLE;
	if ($table==$LINK_ID_TABLE[$type]){
		// Table fields
		switch ($table.".".$field){
			case 'glpi_plugin_example.serial':
				echo "Not really specific - Just for example&nbsp;";
				autocompletionTextField($linkfield,$table,$field);
				// dropdownYesNo($linkfield);
				// Need to return true if specific display
				return true;
			break;
		}

	} else {
		// Linked Fields
		switch ($table.".".$field){
			case "glpi_dropdown_plugin_example.name" :
				echo "Not really specific - Just for example&nbsp;";
				dropdown($table,$linkfield,1,$_SESSION["glpiactive_entity"]);
				//dropdownUsers($linkfield,0,"own_ticket",0,1,$_SESSION["glpiactive_entity"]);
 				// Need to return true if specific display
				return true;
				break;
		}
	}
	// Need to return false on non display item
	return false;
}
}}}

Vous pouvez également définir de nouvelles actions de modifications massives en définissant les fonctions suivantes :
{{{
// Define actions : 
function plugin_example_MassiveActions($type){
	global $LANG;
	switch ($type){
                // New action for core type : name = plugin_PLUGINNAME_actionname
		case COMPUTER_TYPE :
			return array(
				"plugin_example_DoIt"=>"plugin_example_DoIt",
			);
			break;
		case PLUGIN_EXAMPLE_TYPE:
			return array(
				// GLPI core one
				"add_document"=>$LANG["document"][16],
				// Specific one
				"do_nothing"=>'Do Nothing - just for fun'
				);
		break;
	}
	return array();
}

// How to display specific actions ?
function plugin_example_MassiveActionsDisplay($type,$action){
	global $LANG;
	switch ($type){
		case COMPUTER_TYPE:
			switch ($action){
				case "plugin_example_DoIt":
				echo "&nbsp;<input type=\"submit\" name=\"massiveaction\" class=\"submit\" value=\"".$LANG["buttons"][2]."\" >&nbsp;but do nothing :)";
				break;
			}
			break;
		case PLUGIN_EXAMPLE_TYPE:
			switch ($action){
				// No case for add_document : use GLPI core one
				case "do_nothing":
					echo "&nbsp;<input type=\"submit\" name=\"massiveaction\" class=\"submit\" value=\"".$LANG["buttons"][2]."\" >&nbsp;but do nothing :)";
				break;
			}
		break;
	}
	return "";
}

// How to process specific actions ?
function plugin_example_MassiveActionsProcess($data){
	global $LANG;

	if (!isset($_SESSION["MESSAGE_AFTER_REDIRECT"])) $_SESSION["MESSAGE_AFTER_REDIRECT"]="";

	switch ($data['action']){
		case 'plugin_example_DoIt':
			if ($data['device_type']==COMPUTER_TYPE){
				$ci =new CommonItem();
				$_SESSION["MESSAGE_AFTER_REDIRECT"].= "Right it is the type I want...<br>";
				$_SESSION["MESSAGE_AFTER_REDIRECT"].= "But... I say I will do nothing for :<br>";
				foreach ($data['item'] as $key => $val){
					if ($val==1) {
						if ($ci->getFromDB($data["device_type"],$key)){
						$_SESSION["MESSAGE_AFTER_REDIRECT"].= "- ".$ci->getField("name")."<br>";
						}
					}
				}
			}
			break;
		case 'do_nothing':
			if ($data['device_type']==PLUGIN_EXAMPLE_TYPE){
				$ci =new CommonItem();
				$_SESSION["MESSAGE_AFTER_REDIRECT"].= "Right it is the type I want...<br>";
				$_SESSION["MESSAGE_AFTER_REDIRECT"].= "But... I say I will do nothing for :<br>";
				foreach ($data['item'] as $key => $val){
					if ($val==1) {
						if ($ci->getFromDB($data["device_type"],$key)){
							$_SESSION["MESSAGE_AFTER_REDIRECT"].= "- ".$ci->getField("name")."<br>";
						}
					}
				}
			}
		break;
	}

}
}}}

=== Personnalisation de l'export dynamique ===

Il est possible si l'export dynamic standard doit etre personnaliser de le faire en définissant la fonction plugin_PLUGINNAME_dynamicReport($parm). 
$parm etant les paramètres passés en $_GET provenant du Pager (fonction printPager).

{{{
// Do special actions for dynamic report
function plugin_example_dynamicReport($parm){
	if ($parm["item_type"]==PLUGIN_EXAMPLE_TYPE){
		// Do all what you want for export depending on $parm 
		echo "Personalized export for type ".$parm["display_type"];
		// Return true if personalized display is done
		return true;
	}
	// Return false if no specific display is done, then use standard display
	return false;
}
}}}

On peux définir des données en plus à passer à la fonction d'export dynamique en définissant la fonction : plugin_PLUGINNAME_addParamFordynamicReport.
Les paramètres de recherche sont accessibles via les variables de session.

{{{
// Add parameters to printPager in search system
function plugin_example_addParamFordynamicReport($device_type){
	if ($device_type==PLUGIN_EXAMPLE_TYPE){
		// Return array data containing all params to add : may be single data or array data
		// Search config are available from session variable
		return array(
			'add1' => $_SESSION['glpisearch'][$device_type]['order'],
			'add2' => array('tutu'=>'Second Add','Other Data'));
	}
	// Return false or a non array data if not needed
	return false;
}
}}}