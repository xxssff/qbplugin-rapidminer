= Introduction =

Migración de las implementaciones realizadas en YALE 3.4 a RapidMiner 4.1
La idea es utilizar todo lo que RapidMiner 4.1 incluye y reducir la programación propia al mínimo.

= Problema actual =
----
ESTUDIAR:  El !SimilarityUtil es capaz de usar una similitud que le venga en la lista de objetos. ¿se podría crear una similitud que tenga en cuenta la discretización? Si es así ¿habría que modificar el knnlearner?

LECCIONES:
  # Se puede crear un operador que se encargue de crear una similitud en la que almacene el modelo de discretización.
  # Aunque en la lista del inputContainer (que es donde están los objetos que entran a un operador) sólo tenga un modelo éste vendrá  dentro de un !ModelContainer. El apply() de un modelContainer realiza la aplicación secuencial de todos los modelos que incluya.
La cuestión es ver como afecta cuando además del modelo de discretización exista uno de aprendizaje en el !ModelContainer.
  # Hay que crear una clase base de la que dependan todas las similitudes por lo que se pueda requerir; en el caso del kernel hay que almacenar los límites del modelo de discretización. La clase debe definirse al nivel de AbstractRealValueBasedSimilarity para 


----

= Details =
Estructura del plugin

El KnnLearner incluido en RM4.1 permite la aplicación de una similitud que esté en la cadena de objetos de entrada.

  * Se crea un operador cuya salida sea una similitud.

~~qbts.discretization~~

 * ~~yale.operator.learner.lazy Incluye código copiado de RM y ligeramente modificado. Incluye un nuevo KNNLearner y !SimiliarityUtil, ver [KNNLearnerSimilarity razonamiento]~~

[Comentarios] 

= IDEAS =
¿Y si la modificación del KNNLearner y el !SimiliarityUtil se hace para añadir una !UserBasedSimilarity ? Así en lugar de hacer una modificación por similitud se hace una y se crean similitudes que se puedan referenciar para su instanciación. La idea sería añadir un nuevo parámetro en el KNNLearner para poder indicar el camino de la clase a usar. Esto se usa en algún otro operador.... Seguramente habría que añadir una nueva entradas en el !Mapper para colocar la opción de !UserBasedSimilarity. En ese caso se podría ampliar siguiendo el mecanismo usado en 
{{{
UserBasedPerformance

package com.rapidminer.operator.performance;
...
try {
criterionClass = com.rapidminer.tools.Tools.classForName(className);
if (PerformanceCriterion.class.isAssignableFrom(criterionClass)) {
	PerformanceCriterion c = null;
	if ((parameter != null) && (parameter.trim().length() > 0)) {
		java.lang.reflect.Constructor constructor = criterionClass.getConstructor(new Class[] { String.class });
		c = (PerformanceCriterion) constructor.newInstance(new Object[] { parameter });
	} else {
		c = (PerformanceCriterion) criterionClass.newInstance();
	}
	if (!(c instanceof MeasuredPerformance)) {
		logError("Only subclasses of MeasuredPerformance are supported as user based criteria. Skipping '"+className+"'...");
	} else {
		performanceCriteria.add(c);
		if (userCriteria != null)
			userCriteria.add(c);
	}
} else {
	logError("Only subclasses of MeasuredPerformance are supported as user based criteria. Skipping '"+className+"'...");
}


}}}

--------

= [FAQ] =